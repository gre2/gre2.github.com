---
layout: post
title: "（内存）jvm运行结构"
description: ""
category: [java,基础]
tags: [基础]
---
{% include JB/setup %}

# jvm运行结构

### jvm运行结构

一个ClassLoader装载编译后的字节码到运行数据区，然后执行引擎用于执行java字节码

![](https://ws1.sinaimg.cn/large/87a42753ly1fvzxe7f0h0j20bd0ck0vj.jpg)

### jvm运行结构之源码编译

![](https://ws1.sinaimg.cn/large/87a42753ly1fw0lhbgmvhj20gw04u78e.jpg)

### jvm运行结构之类加载

![](https://ws1.sinaimg.cn/large/87a42753ly1fvzy6u2fl5j20ga0il79y.jpg)

### jvm运行结构之类执行

![](https://ws1.sinaimg.cn/large/87a42753ly1fw0mbmfov7j20gw07zdls.jpg)

### jvm运行结构之对象的访问定位

通过栈上的对象引用如何来操作堆上的具体对象有两种，句柄和直接指针

1）句柄访问，java堆将会划分一块内存作为句柄池，对象引用存储的就是对象的句柄地址，而句柄中包含了对象实例数据（堆）与类型数据（对象所属类在方法区的地址）各自的具体地址

2）直接指针访问，对象引用存储的就是对象在堆中的地址

句柄的好处是对象被移动时只会改变句柄中的实例数据的指针，而对象引用本身不需要更改。

直接指针好处是快，节省了一次指针定位的时间开销。

### jvm运行结构之对象的初始化

初始化一个对象首先要检查这个指令的参数是否能在常量池中**定位**到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载，解析和初始化过，如果没有则加载该对象的class文件，该文件的数据会被加载到永久代，并创建一个底层的instanceClass对象代表该class，再为要初始化的对象分配内存空间，优先在线程私有内存空间分配大小，如果空间不足，再到eden分配。

**内存分配的两种方式：**指针碰撞  |  空闲列表

如果java堆中的内存是规整的，所有用过的内存放在一边，空闲的放在一边，中间放着一个指针作为分界点的指示器，分配内存就是把指针向空闲区域挪动一段与对象大小相等的距离，这个方式叫指针碰撞。

如果java堆的内存不规整，使用和空闲内存互相交错，虚拟机创建一个列表，分配内存时从列表找到一块足够大的空间划分给对象实例，并更新列表记录，这个方式叫空闲列表。

**分配内存安全性问题**

分配内存在并发情况下不是安全的（A分配内存，指针还没有修改，B也在使用原来的指针分配内存），一种是对分配内存空间的动作进行同步处理--cas+失败重试保证操作的原子性，另一种是把内存分配的动作按照线程划分在不同的空间进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲TLAB，哪个线程要分配就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定，虚拟机是否使用TLAB可以用-xx:+/-useTLAB参数决定。

**堆中创建对象的过程**

类加载完成后，主线程运行static main时在虚拟机中建栈帧，压栈

执行到new Object（）的时，在heap里创建对象

![](https://ws1.sinaimg.cn/large/87a42753ly1fw0o41h9c3j20af09iaab.jpg)

 对象头：

1.存储运行时的数据例如GC标识位，哈希码，锁状态等信息

2.存放指向方法请类静态数据的指针

实例变量：存放类的属性数据信息，也包括父类

填充数据：对象实例数据不是8字节的倍数，填充数据保证字节对齐









