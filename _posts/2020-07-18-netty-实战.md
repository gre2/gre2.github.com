---
layout: post
title: "netty学习"
description: ""
category: [java,基础]
tags: [基础]
---
{% include JB/setup %}

### netty对nio的什么步骤进行了封装（以server端为例）

nio的实现

* 创建selector

  ```
  selector = Selector.open();
  ```

* 创建serverSocketChannel并注册到selector上，关注什么事件

  ```
  servChannel = ServerSocketChannel.open();
  servChannel.configureBlocking(false);
  servChannel.socket().bind(new InetSocketAddress(port), 1024);
  servChannel.register(selector, SelectionKey.OP_ACCEPT);
  ```

* 事件处理循环，遍历就绪的channel，分别进行处理

  accept事件的处理差不多

  read和write其中的步骤也可以抽象成read，dcode，compute，encode，send

  ```
  while(!Thread.interrupted()){
  	if(selector.select(3000)==0) continue;
  	Set<SelectionKey> selectedKeys = selector.selectedKeys();
  	Iterator<SelectionKey> it = selectedKeys.iterator();
  	SelectionKey key = null;
  	while(it.hasNext()){
  			key = it.next();
  			if (key.isAcceptable()) {
  			
  			}
  			if (key.isReadable()) {
  					handler.handleAccept(key);
  			}
  			if (key.isValid() && key.isWritable()){
  			
  			}
  			it.remove();
  	}
  }
  ```

* netty

  * 对事件处理循环抽象成EventLoop，而EventLoopGroup是多个EventLoop

    分为两个EventLoopGroup，bossGroup（accept），workerGroup（read，write）

  * ServerBootstrap用于配置Server相关参数，并启动Server

  * 设置group的处理类（channelPipeline（包含多个channelHandler）处理read和write的封装（责任链模式））

  * ```
    b.group(bossGroup, workerGroup)
            //配置Server通道，之前是ServerSocketChannel，nio封装成了NioServerSocketChannel
            .channel(NioServerSocketChannel.class)
            //配置通道的ChannelPipeline，ChildChannelHandler就是具体处理read，write的逻辑抽象
            .childHandler(new ChildChannelHandler());
    ```

    ```
    private class ChildChannelHandler extends ChannelInitializer<SocketChannel> {
        @Override
        protected void initChannel(SocketChannel channel) throws Exception {
           channel.pipeline().addLast(new EchoServerHandler());
        }
    }
    ```

    ```
    public class EchoServerHandler extends ChannelInboundHandlerAdapter {
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) {
            ByteBuf in = (ByteBuf) msg;
            System.out.println(
                    "服务器接收到消息：" + in.toString(CharsetUtil.UTF_8));
            ctx.write(in);
        }
    
        @Override
        public void channelReadComplete(ChannelHandlerContext ctx)
                throws Exception {
            //write写到缓冲区，flush才写到网络中去
            ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)
                    .addListener(ChannelFutureListener.CLOSE);
        }
    
        @Override
        public void exceptionCaught(ChannelHandlerContext ctx,
            Throwable cause) {
            cause.printStackTrace();
            ctx.close();
        }
    }
    ```

  * 绑定接口，设置同步启动，同时设置服务端接口关闭，再退出的监听

    ```
    // 绑定端口，并启动server，同时设置启动方式为同步
    ChannelFuture f = b.bind(port).sync();
    // 等待服务端监听端口关闭
    f.channel().closeFuture().sync();
    ```