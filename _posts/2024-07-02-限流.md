---
layout: post
title: "限流"
description: ""
category: [限流]
tags: [限流]
---
{% include JB/setup %}

### 限流方式
* 固定窗口
* 滑动窗口
* 漏桶
* 令牌桶

### 单机限流
* Semaphore（定义并发数，获得许可，没有许可就阻塞，请求完释放许可）
* RateLimiter（定义令牌的产生速度，获取令牌，没有就阻塞）

### nginx限流
* 限制请求速率 [ngx_http_limit_req_module模块中的limit_req_zone + limit_req属性]  

  ```
    http{
        limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
        
        server{
            location /api/{
                limit_req zone=api_limit burst=15;
                ###
            }
        }
    }
  ```
  * $binary_remote_addr：用于限流的客户端IP地址。
  * zone=api_limit:10m：指定限流存储区的名称和大小（例如10MB）。[1M大概能存16000个id，实际配置多大根据业务来定吧]
  * rate=10r/s：定义速率，例如每秒10个请求。
  * zone=api_limit：通过这个关联两块配置
  * burst=15：定义允许的突发请求量缓冲区
  * 小于rate正常处理，大于rate小于burst+rate排队，大于burst+rate请求被返回429 Too Many Requests状态码

* 限制并发连接数 [ngx_http_limit_conn_module模块中的limit_conn_zone + limit_conn属性]
  ```
  http {
        limit_conn_zone $$binary_remote_addr zone=concurrent: 10m;
        limit_conn_zone $binary_remote_addr zone=re:10m ;
        server {
                listen 80;
                server name your server name;
                location /your api endpoint {
                           limit_conn concurrent 10;
                           limit_conn re 100;
                }
        }
  }
  ```
  * 通过缓冲区的名字关联

### gateway限流
```
spring:
cloud:
gateway:
routes:
      - id: test
        uri: lb://Provider  # 路由定义对应的微服务的转发地址：lb;负载均衡 + 服务名称
        filters:
          - name: RequestRateLimiter
            args:
                key-resolver: '#{@pathKeyResolver}'
                redis-rate-limiter.replenishRate: 1
                redis-rate-limiter.burstCapacity: 3
```
```java
@Slf4j
@Configuration
public class KeyResolverConfig {

    /**
     * 基于url
     */
    @Bean
    public KeyResolver pathKeyResolver() {
        System.out.println("基于url限流");
        return exchange -> Mono.just(
                exchange.getRequest().getPath().toString()
        );
    }

    /**
     * 基于用户限流
     */
    @Bean
    KeyResolver userKeyResolver() {
        System.out.println("基于用户限流");
        //按用户限流
        return exchange -> Mono.just(exchange.getRequest().getQueryParams().getFirst("user"));
    }
   
//    @Bean
//    @Primary
//    KeyResolver ipKeyResolver() {
//        System.out.println("基于IP来限流");
//        //按IP来限流
//        return exchange -> Mono.just(exchange.getRequest().getRemoteAddress().getHostName());
//    }

    /**
     * 基于IP来限流
     */
    @Primary
    @Bean
    public KeyResolver ipKeyResolver() {
        return new KeyResolver() {
            @Override
            public Mono<String> resolve(ServerWebExchange exchange) {
                ServerHttpRequest request = exchange.getRequest();
                String remoteAddr = request.getRemoteAddress().getAddress().getHostAddress();
                // 这里根据请求【URI】进行限流
                log.info("这里根据url请求 {}", remoteAddr);
                return Mono.just(remoteAddr);
            }
        };
    }
}
```
### redis-cell
![](https://s21.ax1x.com/2024/07/12/pkhj7F0.png)

```angular2html
127.0.0.1:6379> cl.throttle mytest 99 5 100 2
1) (integer) 0                        #0 表示成功， 1表示失败
2) (integer) 100                      # 令牌桶的容量
3) (integer) 98                       # 当前令牌桶的令牌数
4) (integer) -1                       # 成功时该值为-1，失败时表还需要等待多少秒可以有足够的令牌
5) (integer) 41                       # 预计多少秒后令牌桶会满
```

```java
    @PostMapping("rush")
    public HttpResp  rush(){
        //对接口进行限流操作
        //检查令牌桶，返回的第一值是否为 0: 0-流量够，1-限流中
        String script = "return redis.call('cl.throttle',KEYS[1],ARGV[1],ARGV[2],ARGV[3],ARGV[4])";
        
        List<String> keys = new ArrayList<>();
        keys.add("redbag");
        String maxBurst = "99";  //漏洞容量
        String countPerPeriod = "10";
        String period = "100";
        String quantity = "10";

        List<Long> list = stringRedisTemplate.execute(
                new DefaultRedisScript<>(script,List.class) ,
                keys,
                maxBurst, countPerPeriod, period,
                quantity
        );
        log.debug("限流产假返回结果:{}",list);

        if(!list.isEmpty() && list.get(0)==0){
            return HttpResp.success("抢红包成功，剩余红包:"+(--num));
        }else{
            return HttpResp.failed("当前抢红包人数过多，请2分钟之后再来");
        }
    }
```
```java
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;


@Component
@Aspect
public class FlowLimitAop {

    @Autowired
    private RedisTemplate<String,Object> redisTemplate;

    /**
     * 使用aop前切对接口进行限流
     */
    @Before("execution(* com.wnhz.ssc.actitivity.controller.*.*(..))")
    public void flowLimitAdvice(){
        System.out.println("我准备切接口了....");

        String script = "return redis.call('CL.THROTTLE',KEYS[1], ARGV[1], ARGV[2], ARGV[3], ARGV[4])";
        List list = redisTemplate.execute(
                new DefaultRedisScript<>(script, List.class),
                new ArrayList<String>(){{
                    add("older:activity");//key
                }},
                99,10,100,10);
        System.out.println(list.get(0));
        if(0 != (Long)list.get(0)){  //令牌桶有令牌，可以放行
            throw  new ActivityException("当前祈福人数过多，请等一会儿再来....");
        }
    }
}
```
### sentinel限流



