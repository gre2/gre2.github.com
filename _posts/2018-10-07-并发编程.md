---
layout: post
title: "并发编程"
description: ""
category: [java,基础]
tags: [基础]
---
{% include JB/setup %}

# 并发编程

### AtomicInteger

volatile + unsafe类（native）（cas）来实现的

### ThreadLocal

为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象?

因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal





### synchronized

利用操作系统的MutexLock互斥锁机制实现，利用操作系统的MutexLock互斥锁机制实现。





### AQS

底层是使用Unsafe的park和unpark方法来挂起和唤醒线程。

（volatile）state记录同步状态 + 一个双向链表（Node）实现的队列对线程进行排队和调度

里面的Node类，实现了独占模式（EXCLUSIVE）和共享模式（SHARED）

状态

```
//取消状态，由于在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消等待。 
static final int CANCELLED = 1;
//通知状态，当前节点的后继节点包含的线程需要运行(unpark)当前节点的线程如果释放了同步状态或者被取消，将通知后续节点。
static final int SIGNAL = -1;
//条件阻塞状态，节点线程等待在Condition上，当其他线程对Condition调用了signal()方法后，该节点将会从等待队列中转移到同步队列中，加入到对同步状态的获取中。 
static final int CONDITION = -2;
//传播状态，表示当前场景下后续的acquireShared能够得以执行。
static final int PROPAGATE = -3;
//节点的的状态 初始状态为0  表示当前节点在sync队列中，等待着获取状态。
volatile int waitStatus;
```

for(;;)主要是为了保障两点：

```
一是每个Node挂起前都能将前驱节点的状态设置为SIGNAL
二是在每个Node被唤醒后再次进入锁的获取中
```

独占模式加锁流程

```
s1.调用tryAcquire(1)加锁失败，构造一个独占模式的Node准备入列
s2.如果队列已经初始化，使用compareAndSetTail以CAS的方式将Node设置为尾节点，转入s4;如果队列为空或者设置尾节点失败，转入s3
s3:如果队列未初始化,实例化一个空队列tail和head都指向一个空白节点，使用compareAndSetTail以CAS的方式将Node设置为尾节点，在循环中确保设置成功，转入s4
s4:如果Node节点在队列中拍第二，重试获取锁，获取成功后，将Node设置为头节点直接返回；否则进入s5
s5:返回了true说明当前节点可挂起了，调用parkAndCheckInterrupt()方法将线程挂起，线程挂起操作和CAS操作一样都是调用Unsafe中的native方法。
如果此线程被中断了，他会被唤醒并且返回中断标识true，进入到下次循环，如果拿不到锁还是接着park，如果拿到锁返回到s1，会记录下中断状态selfInterrupt()，用户可以自行处理中断状态，对流程没有任何影响。
```

```
如果前驱节点的状态为CANCELLED表示前驱节点放弃了锁获取，通过循环向前查找到，直到找到最近一个非CANCELLED状态的节点，将node挂在它的后边，CANCELLED节点会被从队列中摘除。
// s5
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus; // 前驱节点状态
    if (ws == Node.SIGNAL)//状态为SIGNAL,说明node可挂起,返回true
        return true;
     if (ws > 0) {//摘掉状态为CANCELLED的前驱节点
         do {
             node.prev = pred = pred.prev;
         } while (pred.waitStatus > 0);
         pred.next = node;// 找到非CANCELLED状态的节点，将Node挂在其后面
      } else {//为-3、-2
          compareAndSetWaitStatus(pred, ws, Node.SIGNAL);// 设置前驱节点为SIGNAL状态
      }
      return false;
}
```

独占模式解锁流程

```
// s1
public final boolean release(int arg) {
   if (tryRelease(arg)) {//解锁成功
       Node h = head;
       if (h != null && h.waitStatus != 0)//头节点不为空&&不在进行中
           unparkSuccessor(h);//唤醒后续节点
       return true;
   }
   return false;
}

// s2
private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws < 0)// head节点状态设置为0
        compareAndSetWaitStatus(node, ws, 0);
    Node s = node.next;
    if (s == null || s.waitStatus > 0) {// s为空或CANCELLED
        s = null;
        // 从尾部开始向前查找，找到一个非CANCELLED状态的节点
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;// 赋给s
    }
    if (s != null)// 唤醒s
        LockSupport.unpark(s.thread);
}
被唤醒的节点还要回到acquireQueued()方法里的挂起点，再次进行锁获取,如果还是没有获取到锁则接着被挂起。
```

共享模式加锁流程

```
1：初始化同步器Sync时，先设定许可共享数，即有多少把锁，许可共享数保存在共享状态state中。
2：每次加锁许可共享数都会减1作为剩余量，当剩余量小于0时，说明没有可用的许可了，直接返回剩余量，AQS中的“acquireShared”发现剩余量小于0,开始构造Node进入排队逻辑。
当还有剩余量(remaining>=0)说明线程还能获取共享锁，剩余量减1，直接返回，取锁成功。
3：释放锁时将剩余量加1，CAS设置state为剩余量，设置成功则释放锁成功。
4：独占锁释放时没有使用CAS操作，因为独占锁释放不存在线程争用，共享锁会出现多个线程释放锁的情况，state存在争用。:
5：需要注意共享锁在唤醒的节点后，如发现还有剩余量，还有节点在排队，将继续唤醒后继节。
```

reference：https://www.jianshu.com/p/d291a6a1879c





### 锁

独占锁也称排它锁，一次只允许一个线程获取到锁，锁未释放前其他线程无法获取到锁。

共享锁是可以有多个线程获取并持有的锁，获取到锁的线程都可以进入同步代码块执行。