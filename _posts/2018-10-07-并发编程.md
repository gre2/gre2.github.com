---
layout: post
title: "并发编程"
description: ""
category: [java,基础]
tags: [基础]
---
{% include JB/setup %}

# 并发编程

### AtomicInteger

volatile + unsafe类（native）（cas）来实现的

### ThreadLocal

为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象?

因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal

### synchronized和Lock

synchronized缺陷：等待锁的线程，除非之前的线程执行完或者出异常（之前的线程执行慢[IO操作]，读操作也要等待），否则无限制的等待，引入lock

异同：

lock可以让等待锁的线程中断，lock是可中断锁，synchronized不可中断

lock可以知道线程获取锁成功还是失败了

lock需要手动上锁和释放锁

Synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。

Lock：底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。

- **as-if-serial语义保证了单线程环境下重排序之后程序执行结果的正确性**，JVM在单线程的情况下会遵as-if-serial语义，无需担心重排序会干扰内存可见性。
- 基于数据依赖性的as-if-serial语义无法保证多线程环境下，重排序之后程序执行结果的正确性。JMM中happens-before原则就是用来保障多线程环境下变量可见性的。

### synchronized

锁语义对临界区进行互斥，保障原子性，有序性，可见性

根据synchronized修饰的目标不同锁定的对象有如下3中情况：

1、修饰普通方法，锁当前对象

2、修饰静态方法，锁当前类的class对象

3、修饰代码块，锁括号中的对象

##### 原理

```
同步代码进入时，JVM底层使用指令entermonitor用来获取monitor的所有权，进行加锁。离开时，使用指令leavemonitor来释放对monitor占用，即解锁。

同步方法进入时，JVM会在方法的常量池中设置ACC_SYNCHRONIZED访问标志，并获取monitor对象，执行完毕会释放掉monitor对象，在此期间其他任何线程都无权获取这个monitor对象，处于阻塞状态。
```

JDK6之前通过操作系统的metuxLock(互斥锁)机制实现，重量级锁

之后对锁进行了一系列的优化，措施之一是引入cas指令

锁的信息保存在对象头的markWord字段中

![](https://ws1.sinaimg.cn/large/87a42753ly1fwh020u5xnj20g3063tak.jpg)

![](https://ws1.sinaimg.cn/large/87a42753ly1fwh8v51ootj20ei05nta0.jpg)

- 偏向锁：为了满足一个线程在无竞争条件下访问同步代码块而设置的锁
- 轻量级锁：为了满足多线程交替执行代码而设置的锁，采用cas和自旋来减少系统级别的互斥操作代来的性能开销
- 重量级锁：通常锁说的互斥锁，利用操作系统的MutexLock互斥锁机制实现，通过对象内的监视器(monitor)进行加锁操作。

##### 锁膨胀过程

![](https://ws1.sinaimg.cn/large/87a42753ly1fwhactzuqcj20h2096goz.jpg)

reference：https://upload-images.jianshu.io/upload_images/2062729-61dfb07d48d8588c.png



##### 可重入

通过对象监视器中递归计数器(_recursion)实现的

##### 非公平锁

在JVM实现中，等待获取锁的线程放入等待_EntryList，_owner指向当前持有锁的线程，_owner被wait后进入阻塞队列_WaitSet，被notify后再次进入等待队列_EntryList，_owner会在解锁时从_EntryList队列头拉出一个等待线程作为备选线程，_owner会把锁竞争的权利交给备选线程，而不是直接把锁交给备选线程，备选线程能不能获取锁还得进行重新竞争，备选线程获取锁即成为_owner线程，获取不了锁则重新进入_EntryList队列等待。这就是JVM线程竞争切换机制的大致流程。



### ReentrantLock

- 公平锁：state==0，获取锁成功，cas改state=1；state>0，代表是重入锁，state++
- 非公平锁：判断aqs队列里面是否有等待的节点，有则放弃获取锁



### AQS

底层是使用Unsafe的park和unpark方法来挂起和唤醒线程。

（volatile）state记录同步状态 + 一个双向链表（Node）实现的队列对线程进行排队和调度

里面的Node类，实现了独占模式（EXCLUSIVE）和共享模式（SHARED）

状态

```
//取消状态，由于在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消等待。 
static final int CANCELLED = 1;
//通知状态，当前节点的后继节点包含的线程需要运行(unpark)当前节点的线程如果释放了同步状态或者被取消，将通知后续节点。
static final int SIGNAL = -1;
//条件阻塞状态，节点线程等待在Condition上，当其他线程对Condition调用了signal()方法后，该节点将会从等待队列中转移到同步队列中，加入到对同步状态的获取中。 
static final int CONDITION = -2;
//传播状态，表示当前场景下后续的acquireShared能够得以执行。
static final int PROPAGATE = -3;
//节点的的状态 初始状态为0  表示当前节点在sync队列中，等待着获取状态。
volatile int waitStatus;
```

for(;;)主要是为了保障两点：

```
一是每个Node挂起前都能将前驱节点的状态设置为SIGNAL
二是在每个Node被唤醒后再次进入锁的获取中
```

独占模式加锁流程

```
s1.调用tryAcquire(1)加锁失败，构造一个独占模式的Node准备入列
s2.如果队列已经初始化，使用compareAndSetTail以CAS的方式将Node设置为尾节点，转入s4;如果队列为空或者设置尾节点失败，转入s3
s3:如果队列未初始化,实例化一个空队列tail和head都指向一个空白节点，使用compareAndSetTail以CAS的方式将Node设置为尾节点，在循环中确保设置成功，转入s4
s4:如果Node节点在队列中拍第二，重试获取锁，获取成功后，将Node设置为头节点直接返回；否则进入s5
s5:返回了true说明当前节点可挂起了，调用parkAndCheckInterrupt()方法将线程挂起，线程挂起操作和CAS操作一样都是调用Unsafe中的native方法。
如果此线程被中断了，他会被唤醒并且返回中断标识true，进入到下次循环，如果拿不到锁还是接着park，如果拿到锁返回到s1，会记录下中断状态selfInterrupt()，用户可以自行处理中断状态，对流程没有任何影响。
```

```
如果前驱节点的状态为CANCELLED表示前驱节点放弃了锁获取，通过循环向前查找到，直到找到最近一个非CANCELLED状态的节点，将node挂在它的后边，CANCELLED节点会被从队列中摘除。
// s5
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus; // 前驱节点状态
    if (ws == Node.SIGNAL)//状态为SIGNAL,说明node可挂起,返回true
        return true;
     if (ws > 0) {//摘掉状态为CANCELLED的前驱节点
         do {
             node.prev = pred = pred.prev;
         } while (pred.waitStatus > 0);
         pred.next = node;// 找到非CANCELLED状态的节点，将Node挂在其后面
      } else {//为-3、-2
          compareAndSetWaitStatus(pred, ws, Node.SIGNAL);// 设置前驱节点为SIGNAL状态
      }
      return false;
}
```

独占模式解锁流程

```
// s1
public final boolean release(int arg) {
   if (tryRelease(arg)) {//解锁成功
       Node h = head;
       if (h != null && h.waitStatus != 0)//头节点不为空&&不在进行中
           unparkSuccessor(h);//唤醒后续节点
       return true;
   }
   return false;
}

// s2
private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws < 0)// head节点状态设置为0
        compareAndSetWaitStatus(node, ws, 0);
    Node s = node.next;
    if (s == null || s.waitStatus > 0) {// s为空或CANCELLED
        s = null;
        // 从尾部开始向前查找，找到一个非CANCELLED状态的节点
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;// 赋给s
    }
    if (s != null)// 唤醒s
        LockSupport.unpark(s.thread);
}
被唤醒的节点还要回到acquireQueued()方法里的挂起点，再次进行锁获取,如果还是没有获取到锁则接着被挂起。
```

共享模式加锁流程

```
1：初始化同步器Sync时，先设定许可共享数，即有多少把锁，许可共享数保存在共享状态state中。
2：每次加锁许可共享数都会减1作为剩余量，当剩余量小于0时，说明没有可用的许可了，直接返回剩余量，AQS中的“acquireShared”发现剩余量小于0,开始构造Node进入排队逻辑。
当还有剩余量(remaining>=0)说明线程还能获取共享锁，剩余量减1，直接返回，取锁成功。
3：释放锁时将剩余量加1，CAS设置state为剩余量，设置成功则释放锁成功。
4：独占锁释放时没有使用CAS操作，因为独占锁释放不存在线程争用，共享锁会出现多个线程释放锁的情况，state存在争用。:
5：需要注意共享锁在唤醒的节点后，如发现还有剩余量，还有节点在排队，将继续唤醒后继节。
```

reference：https://www.jianshu.com/p/d291a6a1879c





### 锁

独占锁也称排它锁，一次只允许一个线程获取到锁，锁未释放前其他线程无法获取到锁。

共享锁是可以有多个线程获取并持有的锁，获取到锁的线程都可以进入同步代码块执行。



### 线程池

```java
private static final RejectedExecutionHandler defaultHandler =
        new AbortPolicy();
this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
     Executors.defaultThreadFactory(), defaultHandler);
```

先核心，再缓冲队列，再最大，再拒绝策略，达到存活时间（keepAliveTime）回收

四种线程池

```
1）newCachedThreadPool
2）newFixedThreadPool  
3）newScheduledThreadPool
4）newSingleExecutor 

1：无界，后面任务执行时，前面任务已经执行完会复用前面的线程 >> 核心=0，最大=Integer.max_value,SynchronousQueue
2：定长，控制最大并发数，超出线程放在队列中等待 >>核心，最大一样大，time=0，LinkedBlockingQueue
3：延迟，周期执行 >> DelayQueue无界队列
4：单线程化的线程池 >> 核心，最大=1 其余和fixed一样
```





### 条件队列Condition

维护一个链表Node，用来进行阻塞线程的排队和调度，称为条件队列

Condition是J.U.C包中的一个接口，提供了三个主要方法await、signal和signalAll。和Object中的wait、notify、notifyAll三个监视器方法语义一致，监视器方法必须放到synchronized修饰的同步体内，Condition接口也是一样，要放到Lock的监视范围也就是lock和unlock之间的代码块内调用

线程调用了condition.await()后将先释放该线程持有的锁，构造成Node加入条件队列，然后再挂起该线程。

其他线程调用了condition.signal()后，将条件队列中第一个等待的Node节点转移到AQS同步队列，在AQS同步队列中参与锁获取的调度，如果获取到锁则该线程被唤醒。



### 



