---
layout: post
title: "rocketmq"
description: ""
category: [java,基础]
tags: [基础]
---
{% include JB/setup %}

# Rocketmq

### producer发送消息

producer.start()其实是调用DefaultMQProducerImpl.start()调用MQClientInstance.start()

> 因为生产和消费者都会持有MQClientInstance所以在启动任务的时候会启动生产和消费相关的任务线程

> ```
> boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);
> ```
>
> 把DefaultMQProducer对象添加到MQClientInstance的producerTable属性中
>
> ```java
> private final ConcurrentHashMap<String/* group */, MQProducerInner> producerTable = new ConcurrentHashMap<>();
> ```

> ```java
> mQClientFactory.start();
> ```
>
> 启动通信服务和定时任务
>
> ```java
> MQClientAPIImpl.start()  ----> NettyRemotingClient.start()
> ```
>
> MQClientAPIImpl(客户端与远程交互的封装,其内部使用了RemotingClient来实现与远程的交互)
>
> NettyRemotingClient.start()的方法里面启动了netty的通信客户端

>```java
>this.startScheduledTask();
>```
>
>启动各种定时任务
>
>* 每两分钟执行一次寻址服务(NameServer地址)
>* 每30秒更新一次所有的topic的路由信息(topicRouteTable)
>* 每30秒移除离线的broker ， 每30秒发送一次心跳给所有的master broker
>* 每5秒提交一次消费的offset（逻辑偏移量）到broker（broker端为ConsumerOffsetManager负责记录）
>* 每1分钟调整一次线程池，这也是针对消费者来说的，具体为如果消息堆积超过10w条，则调大线程池，最多64个线程，如果消息堆积少于8w条，则调小线程池，最少20个线程

```java
this.pullMessageService.start();
```

> consumer的拉取消息线程方式实现：pullMessageService继承ServiceThread（对拉取消息请求进行了封装，使其队列化），start拉取消息线程启动，在run方法里面实现了pullMessageService#run），不断的从pullRequestQueue中取出请求，并调用消息拉取（pullMessageService#pullMessage）

```java
this.rebalanceService.start();
```

```java
this.defaultMQProducer.getDefaultMQProducerImpl().start(false);
```

