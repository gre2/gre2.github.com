---

layout: post
title: "spring学习"
description: "spring"
category: [java,spring]
tags: [spring]
---
{% include JB/setup %}

# spring学习

spring自己写了一些小例子

git@github.com:gre2/wuleispring01.git

git@github.com:gre2/wuleispring02.git

git@github.com:gre2/wuleispring03.git
***

Aware接口

实现这些接口的bean被实例化后，可以取得一些相对的资源

***

BeanDefinitionParser接口

解析各种配置文件的类都实现了

***

BeanPostProcessor：修改bean实例信息（属性值）

BeanFactoryPostProcessor：修改bean定义信息（作用域）

reference：https://www.jianshu.com/p/81349bb9859d

***

```
<context:component-scan base-package="com.qiyi.task"/>
```

**<context  :**node.getNamespaceURI() ==http://www.springframework.org/schema/context

***

BeanDefinitionReaderUtils：把所有的bean存储起来的

AnnotationConfigUtils：包扫描之后的bean处理，作用？
***
BeanFactory：IOC的顶级接口，访问spring容器的根接口，负责bean的创建，访问。

FactoryBean：首先是一个bean，之后这个FactoryBean是可以返回bean的实例，通过实现该接口可以对bean进行一些额外的操作，（比如根据不同的配置类型返回）。

reference：https://www.jianshu.com/p/ae274e71ae9f



**BeanFactory接口中有一个字符常量`String FACTORY_BEAN_PREFIX = "&";`**

当我们去获取BeanFactory类型的bean时，如果beanName不加&则获取到对应bean的实例；如果beanName加上&，则获取到BeanFactory本身的实例。

Spring本身就提供了70多个FactoryBean的实现。他们隐藏了实例化一些复杂的细节，给上层应用带来了便利。

![](/Users/wulei/Desktop/tc/87a42753ly1fw5jjf9mbrj21a40phwjp.png)

图解：蓝色：类与类；绿色实线：接口与接口；绿色虚线：类和接口

顶级接口分析：`BeanFactory`,`SingletonBeanRegistry`,`AliasRegistry`

reference：https://www.jianshu.com/p/e50a848932e0

***
# refresh方法

#### obtainFreshBeanFactory()方法

loadBeanDefinitions方法在web.xml里面获取classpath*:applicationContext.xml

```
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath*:applicationContext.xml</param-value>
</context-param>
```

![](/Users/wulei/Desktop/tc/87a42753ly1fw4bhhl2pvj20qc0e6whi.png)

通过ResourceLoader得到Resource对象，找到配置文件的完全限定类名，进行加载

![](https://ws1.sinaimg.cn/large/87a42753ly1fw4bkw7c9nj210p0gxjui.jpg)

根据Resource对象得到流对象，loadBean

![](https://ws1.sinaimg.cn/large/87a42753ly1fw4bo4ciq8j217i0ht0ws.jpg)

根据文件路径的流对象和Resource对象，返回一个Document对象



```
Element root = doc.getDocumentElement();
```

doRegisterBeanDefinitions(root)初始化BeanDefinition

**重点关注下BeanDefinitionParserDelegate**：里面定义了bean文件所有用到的标签

```
this.delegate = createDelegate(getReaderContext(), root, parent);
```

createDelegate方法定义了一些xml文件里面最基本的属性值

![](https://ws1.sinaimg.cn/large/87a42753ly1fw4ejv37v1j20cj07xt9d.jpg)



```
preProcessXml(root);
parseBeanDefinitions(root, this.delegate);
postProcessXml(root);
```

两个后置处理器，处理element对象的，交给子类去做，主要是parseBeanDefinitions

![](https://ws1.sinaimg.cn/large/87a42753ly1fw4f5t27hdj20jo0alwfg.jpg)

![](https://ws1.sinaimg.cn/large/87a42753ly1fw4l1emx57j20lj0eqac1.jpg)

解析xml中的标签文件，所有解析出来的数据都给DefaultListableBeanFactory的属性赋值了

```
/** Map of bean definition objects, keyed by bean name */
private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<String, BeanDefinition>(256);

/** List of bean definition names, in registration order */
private volatile List<String> beanDefinitionNames = new ArrayList<String>(256);
```

解析<context:component-scan base-package="com.qiyi.task"/>类似的标签

![](https://ws1.sinaimg.cn/large/87a42753ly1fw4gd5j9lbj20w40izjvt.jpg)

BeanDefinitionParse的实现类NamespaceHandlerSupport类

```
findParserForElement(element, parserContext).parse(element, parserContext);
```

执行此方法，为了除了bean之后的标签找到自己的parse

包扫描ComponentScanBeanDefinitionParser

```
@Override
public BeanDefinition parse(Element element, ParserContext parserContext) {
   String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);
   basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);
   String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,
         ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);

   // Actually scan for bean definitions and register them.
   ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);
   Set<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);
   registerComponents(parserContext.getReaderContext(), beanDefinitions, element);

   return null;
}
```

此方法首先找到 base-package，之后针对element构造一个ClassPathBeanDefinitionScanner对象，解析了额外很多属性（ComponentScanBeanDefinitionParser）

![](https://ws1.sinaimg.cn/large/87a42753ly1fw4lhhdn95j20qq0judjj.jpg)

两个后置处理器，对beanDefinition进行处理，registerBeanDefinition方法把bean注册到DefaultListableBeanFactory属性里面

给包扫描的类，注册处理器

![](https://ws1.sinaimg.cn/large/87a42753ly1fw4lkwzeq2j20si0ixgoq.jpg)

所有的bean都被扔到了beanmap对象里面|（初始化遍历ioc对象的时候才会判断注解，之后实例化，之后自动装配）



不错的文章：https://www.jianshu.com/p/01d8c57949a6



#### prepareBeanFactory方法

```
beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
```

ApplicationContextAwareProcessor实现了BeanPostProcessor接口

在BEAN初始化之前，调用ApplicationContextAwareProcessor的postProcessBeforeInitialization，处理所有的Aware接口

```
beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
```

忽略各种Aware接口的注册，因为ApplicationContextAwareProcessor把所有Aware接口都实现了



```
 // 设置几个自动装配的特殊规则     beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);     beanFactory.registerResolvableDependency(ResourceLoader.class, this);     beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);     beanFactory.registerResolvableDependency(ApplicationContext.class, this);
```

给DefaultListableBeanFactory中resolvableDependencies赋值

```
/** Map from dependency type to corresponding autowired value */
private final Map<Class<?>, Object> resolvableDependencies = new HashMap<Class<?>, Object>(16);
```



```
if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {   
     beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));        beanFactory.setTempClassLoader(new 
     ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));    
}
```

如果beanFactory中包含为loadTimeWeaver的Bean，则添加BeanPostProcessor实现：LoadTimeWeaverAwareProcessor，它是用来处理AspectJ**类加载期（静态代理）**织入LTW（Load Time Weaving）的。



注入environment、systemProperties、systemEnvironment三个Bean



#### postProcessBeanFactory方法

beanFactory后置处理,是一个模板方法，交由不同的ApplicationContext实现自己处理逻辑，做一些特有的操作。



#### invokeBeanFactoryPostProcessors方法

查找到容器中注册的BeanFactoryPostProcessors连同直接添加的BeanFactoryPostProcessors进行排序，排序的依据的@Order注解，然后依次调用。

首先最开始解析ConfigurationClassPostProcessor（在容器初始化时注册到容器中的），使用ConfigurationClassParser来解析ConfigurationClass中的配置



#### registerBeanPostProcessors()方法

注册BeanPostProcessor，从Spring容器中找出的实现了BeanPostProcessor接口的Bean，并设置到BeanFactory中,之后bean被实例化的时候会调用这些BeanPostProcessor。



#### onRefresh()方法

这是一个模板方法，交由不同的子类实现处理自己的逻辑。比如web程序的容器AnnotationConfigEmbeddedWebApplicationContext中会调用createEmbeddedServletContainer方法去创建内置的Servlet容器。



#### finishBeanFactoryInitialization方法

初始化非延迟加载的单例Bean， 实例化BeanFactory中已经被注册但是未实例化的所有实例

**invokeBeanFactoryPostProcessors方法中根据各种注解解析出来的类，在这个时候都会被初始化。实例化的过程各种BeanPostProcessor开始起作用。**



# Configuration类解析

Spring中对Configuration类的解析是通过ConfigurationClassPostProcessor进行的，这个类是BeanFactoryPostProcessor的实现，在容器刷新方法中invokeBeanFactoryPostProcessors(beanFactory)这个方法调用所有的BeanFactoryPostProcessor，同时也就启动了Configuration类解析的。







# 实例化bean

preInstantiateSingletons方法，类DefaultListableBeanFactory

- getBean
- doGetBean
- createBean(beanName, mbd, args);
- bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);



后置处理器开始运作org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation



