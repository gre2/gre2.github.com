---
layout: post
title: "rocketmq浅识"
description: ""
category: [java,rocketmq]
tags: [rocketmq]
---
{% include JB/setup %}

# ROCKETMQ浅识

### 1.背景：以前用的amq，海量消息吞吐量低，不抗压，不支持多机房部署

### 2.架构图

![](https://ws1.sinaimg.cn/large/87a42753ly1fwa0su4x0fj20ld08egm6.jpg)

### 3.消费模型

![](https://ws1.sinaimg.cn/large/87a42753ly1fwa0omq6vfj20kl095mzc.jpg)

消费组之间消费进度独立，topic被分成多个messageQueue，为并行消费提供可能

### 4.流程

broker向nameser周期性注册，包含信息：broker的信息，id，ip，ha地址；自身上topic的信息，topic的名称，包含多少messageQueue，生产者从namser上找到自己想要生产的路由topic信息，根据路由信息找到指定的broker，找到指定的topic，找到指定的messageQueue进行发送；消费者从里面拿到路由信息进行消费；

messageQueue只是存储了消息的索引，数据存在一个broker的commit log中

### 5.概念介绍

```
Broker:消息队列的服务端，消息实际存储的地方
NameServer：服务发现装置，broker注册到nameServer上，producer和consumer通过nameServer发现broker的地址
Topic:每个消息都属于某个主题，消息在消息队列按主题分离
ConsumerGroup：消费组，多个消费者组成一个组，共同消费某个topic，可以起到组内负载均衡的作用
MQ:看做消息传递的媒介，生成者投递消息到MQ(消息队列)，消费者从MQ（消息队列）获取消息
```

### 6.消费模型

![](https://ws1.sinaimg.cn/large/87a42753ly1fwabvjfvi9j20im0bfafj.jpg)



### 7.消费模式

```
1.listen
2.pull:自己维护messageQueue与offset
```

### 8.发送失败，重试

生产者内部都有发送失败会自动进行重试，重试次数可配置。对于同步发送，可以通过配置项`setRetryTimesWhenSendFailed(int retryTimesWhenSendFailed)`来设置发送重试次数。对于异步发送，可以通过配置项`setRetryTimesWhenSendAsyncFailed(final int retryTimesWhenSendAsyncFailed)`来设置重试次数。这个自动重试可能造成消息重复，需要注意。通过参数可以设置自动重试，但是自动重试有可能造成消息的重复。

### 9.消费失败，重试

可以，Listener内的业务逻辑执行失败时，返回RECONSUME_LATER，表示消息处理失败需要重新消费。消息会被发送回Broker，等待一段时间后被Consumer再次获取。

### 10.ack

```
1.success，消费成功，，更新进度
2.reconsume—later：失败，送回broker（retry队列），更新进度
3.null:打日志，置为reconsume—later
4.异常
5.hang住不返回，consume一直被block

注：
全hang住，消息有个阈值在内存，所有不再消费
定时任务，工作线程，15分钟检查，获取hang住的consume，送回broker，把消费进度更新掉，正常消费了
```

### 11.并行ACK

提交自己messageQueue未被处理的最小的offset到本地内存

![](https://ws1.sinaimg.cn/large/87a42753ly1fwacj1zclaj20pe0gmguk.jpg)

 consumeThread_1一直没有处理成功，定时任务（超时时间=15分钟）检查阻塞一直没有返回成功处理的消息，把消息送回broker（retry队列，非messageQueue那个队列），并且更新进度

没有从内存写回broker，挂了，消息进度丢了，会重复消费



### 12.consumer何时提交offset到broker

1.周期性任务5s

2.shutdown

3.rebalance发现queue不在分配给自身时

### 13.broker如何存储offset

![](https://ws1.sinaimg.cn/large/87a42753ly1fwacz15zmgj20ps0c3aep.jpg)

红色是queueId

### 14.消费组里的消费者如何均分topic下的messageQueue

```
consume有个rebalance过程：把messageQueue列表分配到consume列表的一个过程
相关接口：AllocateMessageQueueStrategy
```

### 15.同步复制和同步刷盘

```
复制是 master-> slave:异步复制的实现思路非常简单，Slave启动一个线程，不断从Master拉取CommitLog中的数据，然后在异步build出Consume Queue数据结构。整个实现过程基本同Mysql主从同步类似。
刷盘是 cache -> disk（磁盘）:异步刷盘写完PAGECACHE直接返回，而同步刷盘需要等待刷盘完成才返回
```

### 17.重复消费

1. Kill -9直接终止consume进程，消费进度未被提交到broker
2. 有consume重启，group内发生rebalance时，部分消息消费进度未提交
3. 生产者多次发送一条相同的消息（broker写入成功，但是返回写到producer超时，生成者重试）

### 18.丢消息

1.消息未被消费，存放消息的磁盘发生不可逆的损坏

2.消息在系统pageCache内，且未被消费，服务器断电

解决方案：

1.开启同步复制

2.开启同步刷盘

### 5.刷盘模式

```
1.同步：消息落到磁盘才返回成功
2.异步：在消息写入master后即返回producer，不需要等待slave把数据复制过去，但是在master磁盘故障后，未同步到slave的数据可能丢失，其余情况不会丢失
```

### 20.数据保存时间

无论是否消费过，broker上的数据超过数据保存时间后会被自动清理，默认72h

### 21.新来的消费者组从哪里开始消费

用户启动Consumer时，可以通过方法`setConsumeFromWhere(consumeFromWhere)`来配置消费组从何处开始消费。ConsumerFromWhere提供以下选择：

- CONSUME_FROM_LAST_OFFSET 从最后的消息开始消费

- CONSUME_FROM_FIRST_OFFSET 从最前的消息开始消费

- CONSUME_FROM_TIMESTAMP 从指定的时间点开始消费

### 22.消费者从某个offset开始消费

PushConsumer不可以

PullConsumer可以，但是需要自己维护offset

### 23.发现消费者不消费时，该如何诊断？

首先确认消费者的连接状态，是否正常连接Broker。如果连接没有问题，看消息是否该消费者是否有分配到ConsumeQueue，如果未分配到，一般是由于消费者数目超过了ConsumeQueue的总数。如果分配到了，看该分配到的ConsumeQueue上是否有消息生产进来，通过看**brokerOffset和consumerOffset**就可以知道是消息未生产，还是消费者不消费。如果确认是消费者连接正常，分配正常，生产者生产正常，那么需要查看消费者的客户端日志再进一步分析。

### 24.有序

在分布式环境中保持有序比较困难，RocketMQ支持局部有序。这要求Producer生产时，将有序消息按照一定规律进行分片，生产到同一个ConsumeQueue中。同时Consumer消费时，注册的MessageListener需要选择是有序的listener。

但是在分布式环境中，出现Broker的扩容缩容时或者Consumer的上线下线时，会发生Consume Queue的Rebalance。很容易就导致分片规则失效，从而影响消息的有序消费。业务需要仔细考虑这种情况。



### 25.对于慢消费的影响和amq比较

ActiveMQ对于慢消费者的容忍度很低，目前使用上观察到ActiveMQ会自动Kill慢消费者。对于非持久化的消息，慢消费者会导致Broker释放不掉内存，同时影响消费和生产。对于持久化的消息，消息可以先存储下来，但是如果消费者落后太多仍然会影响性能。

更为关键的是，在桥接场景中，如果Broker A认为Broker B的代理消费者为慢消费者，则桥接会断开。从而导致Broker A和Broker B之间消息无法正常流转。影响正常的消息消费。

RocketMQ对于慢消费者则不会很敏感。由于默认数据都是持久化的，不会由于慢消费者没有ACK消息而对Broker的内存产生任何影响。同时，如果慢消费者消费落后很多，消费很早以前的消息，可能会对Broker的性能产生一些影响，因此，Broker可以配置阈值，组织消费多少字节之前（默认16G）的消息的消费者。



### 26.可扩展性和amq比较

ActiveMQ基本不具有横向扩展的能力，如果发现ActiveMQ的吞吐已经无法满足当前业务场景，只有选择纵向扩展。也就是切换成性能更好的机器重新部署，而无法通过增加机器进行横向扩展。

RocketMQ本身就是分布式设计，从Broker到Producer/Consumer都可以集群化部署。如果发现集群吞吐到达瓶颈，只需要通过新增机器就可以达到横向扩容，全程透明。

### 27.HA和amq比较

![](https://ws1.sinaimg.cn/large/87a42753ly1fwad0wy6m3j20p30fdq94.jpg)

多master，配置文件设定，4个broker，双master、双slave。其中一个master宕机，另外一个master生产，生产能力不会停止，消费由slave负责。

**问题？**slave从master同步数据有延迟，slave从master完全同步到数据时，master宕机，master不重启，消费者在slave中消费不到

**解决：**同步复制（4个broker，两个slave都同步成功，才是写入成功）

ActiveMQ的HA通过部署BrokerA和BrokerB，以及在生产者和消费者配置Failover的URL来达成。如果BrokerA出现问题，生产和消费可以Failover到BrokerB上，但是这种模式极度依赖于BrokerA和BrokerB之间的桥接，如果桥接断开，正常的消费都无法满足。

RocketMQ的HA通过Master/Slave模式以及集群化部署达成。Slave会备份Master所有消息，如果Master出现问题，消费者可以切换到Slave上进行消费。同时生产者会将生产切换到其他可用Master进行。

### 28.消息ack和kafka比较

Kafka的Push模式消费时，后台会周期性的自动ACK消息。

如果消息到达Consumer，但是还未处理完毕，消息可能已经被ACK，如果此时Consumer重启，则消息丢失。

RocketMQ的Push模式消费时，后台同样会周期性的自动ACK消息。

但是用户可以在自定义Listener中，通过返回不同的返回值，来确认哪些消息是可以被ACK，哪些消息是消费失败需要重新Delivery的。即使Consumer重启，也不会丢失未消费的消息。

### 29.QPS

虚拟机 8核16G

```
Broker为异步复制模式时
1K的消息体，标准集群的生产消费QPS可以到50K左右（一个Master25K左右）。
10K的消息体，标准集群的生产消费QPS可以到15K左右（一个Master7K左右）。
```

物理机 48核188G

```
Broker为异步复制模式时，1K的消息体，QPS可以到17万。使用批量发送小包时，QPS可以到60万。
Broker为同步复制模式时，1K的消息体，QPS可以到1.4万。瓶颈在于等待Slave同步的网络传输时间，所以一批发多个小包可以明显提升性能，使用批量发送时，QPS可以到40万。
```



