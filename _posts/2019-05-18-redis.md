---
layout: post
title: "redis"
description: ""
category: [java,redis]
tags: [redis]
---
{% include JB/setup %}



# redis

* Redis的操作之所以是原子性的，是因为Redis是单线程的。
* redis速度快是因为是内存数据库，其次是其独特的IO多路复用模型

多路复用模型

![](http://ww1.sinaimg.cn/large/87a42753ly1g36k6rdagcj218e0jago6.jpg)

redis-client在操作的时候，会产生不同事件类型的socket，在服务端，有一段I/O多路复用程序，将其置入队列中，然后文件事件分派器，依次从队列中取，转发到不同的事件处理器中。

redis提供了多路复用函数库，epoll是最常用的，时间复杂度O(1)

* redis过期
  - **定期删除**：redis默认是每隔 100ms 就**随机抽取**一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
  - **惰性删除** ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！
  - 问题：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ **redis 内存淘汰机制。**
* redis内存淘汰机制(allkeys-lru)（这个是最常用的）
  - **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
  - **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
  - **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
  - **allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
  - **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
  - **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！
* 持久化
  
  - rdb：快照(默认)
  
     > 作用：
     >
     > 1.将快照复制到其他服务器，创建具有相同数据的服务器副本(主从)
     >
     > 2.重启服务器时使用
     >
     > 触发条件，redis.conf配置
     >
     > ```
     > save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
     > 
     > save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
     > 
     > save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
     > ```
  
  - aof：追加文件
  
     > 好处：实时性更好，appendonly yes配置，默认不开启
     >
     > 触发条件，最好第二个
     >
     > ```
     > appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
     > appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
     > appendfsync no        #让操作系统决定何时进行同步
     > ```

* 雪崩，缓存穿透

  * 雪崩

    >  简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
    >
    >  解决办法：
    >
    >  - 事前：给缓存的失效时间，加上一个随机值，避免集体失效。
    >  - 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
    >  - 事中：双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。(维护两套缓存)
  >  - 事后：利用 redis 持久化机制保存的数据尽快恢复缓存
  
*   穿透
  
    >简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
    >
    >解决办法： 
    >
    >有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
    >
    >另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
    >
    >还有利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。

* 分布式锁

  * redis(setnx)

    >问题：
    >
    >主redis宕机，从redis变成主，但是主从同步是异步的，在复制数据的时候出现宕机的情况，导致分布式锁失效
    >
    >先更新数据库，再删除缓存，最稳妥，如果删除缓存失败，把删除命令放入队列里面，循环执行

  * zk

    > 指定节点(locker)下创建临时顺序节点node_n，获取locker下的所有子节点children，对节点进行排序(小到大)，判断node_n是否在sortedChildren中的第一个，是的话获得锁，否的话监听node_n-1的删除事件，循环查locker下的所有子节点children，再进行。

* redis hash扩容

  > 渐近式rehash

* redis sortSet

  > 跳表，优化之后的链表，把数据分层级



Reference:https://www.cnblogs.com/xdyixia/p/9110116.html