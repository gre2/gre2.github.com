---
layout: post
title: "mysql问答"
description: "mysql"
category: [java,mysql]
tags: [mysql]
---
{% include JB/setup %}

# mysql问答

### 索引类型

1.聚集索引（一般是主键）：决定数据在磁盘上的物理排序，一个表只能有一个聚集索引

2.非聚集索引：索引上只包含被建立索引的数据，以及一个行定位符，这个行定位符，可以理解为一个聚集索引物理排序的指针，通过这个指针，可以找到行数据

3.覆盖索引：被查询的所有列都是索引，这时不用通过行定位符再到row上获取

### 为什么需要主键（聚集索引）

innodb自增主键会把数据自动向后插入，避免了插入过程中的聚集索引的排序问题，聚集索引的排序，必然会带来大范围的数据的物理移动，带来磁盘io的性能损耗，如果聚集索引的值可以改变的话，那么也会发出物理磁盘上的移动，于是就可能出现磁盘页分裂（索引存储在磁盘上！！！），表碎片横生

### MongoDb索引的数据结构   -   B-树

##### 1.索引为什么要树结构存储

树的查询效率高，而且有序

##### 2.为什么没有用二叉树呢

二叉树时间复杂度O(logN)，从算法逻辑来讲，查找速度和比较次数都是最小的，但是磁盘IO问题，数据库的索引存储在磁盘上，当数据量很大的时候，索引几个G，不可能把整个索引全部加载到内存，能做的只是逐一加载每一个磁盘页，这里的磁盘页对应索引树的节点。

![](https://ws1.sinaimg.cn/large/87a42753ly1fvlvftf330j20jx0e30uj.jpg)

二叉树的查找，4次磁盘IO，找到元素10

![](https://ws1.sinaimg.cn/large/87a42753ly1fvlvgx5m6rj20gp0bw41f.jpg)

为了减少磁盘IO，我们需要把瘦高的树，变的矮胖，这就是B-树的特征之一。

##### 3.B-树

**多路平衡查找树，它的每个节点最多包含k个孩子，k被称为B树的阶，k的大小取决于磁盘页的大小。**

特征：

1.根节点最少两个子女

2.每个中间节点都包含k-1个元素和k个孩子，m/2<=k<=m

3.每个叶子节点都包含k-1个元素，m/2<=k<=m

4.所有的叶子节点位于同一层

5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的至于分划

![](https://ws1.sinaimg.cn/large/87a42753ly1fvlvt44mkoj20is07xgn7.jpg)

在内存中定位，比较3,5，相比于磁盘IO的速度，内存耗时可以忽略不计

##### 4.B-树的卫星数据

![](https://ws1.sinaimg.cn/large/87a42753ly1fvm1bzgqk0j20it0bigos.jpg)

##### 5.B-树的新增   -  自平衡

![](https://ws1.sinaimg.cn/large/87a42753ly1fvm0w2uma1j20iy0np42z.jpg)

##### 6.B-树的删除

![](https://ws1.sinaimg.cn/large/87a42753ly1fvm0zq0bdij20jd0x0gsf.jpg)

### Mysql索引数据结构

B+树是基于B-树的一种变体，有着比B-树更高的查询性能

##### B+树的特征

1.k阶b+树，中间节点包含k个元素（B-树是k-1个元素），每个元素不保存数据，只用来记录索引，所有数据都保存在叶子节点

2.所有叶子节点包含了全部的元素信息，及指向含这些元素记录的指针，且叶子节点本身依关键字的大小自小而大顺序连接

3.所有中间节点元素都同时存在于子节点，在子节点元素中是最大或最小元素

   **叶子节点形成了一个有序链表**

![](https://ws1.sinaimg.cn/large/87a42753ly1fvm18yl4guj20im07cjt3.jpg)

##### B+树的卫星数据

卫星数据指的是索引元素指向的数据记录，比如数据库中的某一行

**在数据库的聚集索引中，叶子节点直接包含卫星数据，在非聚集索引中，叶子节点带有指向卫星数据的指针**

![](https://ws1.sinaimg.cn/large/87a42753ly1fvm1d3slqtj20iv0ao771.jpg)

##### B+树查询性能（单行查询  +  范围查询）之三个优势

在B+树中**单行查询**找3这个元素和B-树的不同体现在

1.B+树中间节点没有卫星数据，相同大小的磁盘页可以容纳更多的节点元素，IO次数更少

2.B+树查询必须找到叶子节点查询性能稳定

![](https://ws1.sinaimg.cn/large/87a42753ly1fvm1ff5calj20iy0ss7ae.jpg)



在B+树中**范围查询**找3到11的元素和B-树的不同体现在

1.B-树只能采用中序遍历的方法，B+树只需要在链表上做遍历即可



![](https://ws1.sinaimg.cn/large/87a42753ly1fvm1l3dqblj20he1c4aig.jpg)



![](https://ws1.sinaimg.cn/large/87a42753ly1fvm1mhjd48j20h20rewju.jpg)



### Mysql事物的隔离级别

重复读是mysql默认的隔离级别

脏读：一个未提交事物可以读到另一个事物没有提交的数据

不可重复读：一个未提交事物可以读到另一个事物已经提交的数据

幻读：一个未提交事物不能读到另一个事物已经提交或者未提交的数据，只有事物1提交之后，才可以看见事物2对数据的更改

串行化：强制事物排序，使之不可能存在相互冲突，事物1没有提交之前，不允许事物2更改数据

### 如何防止幻读  -   间隙锁

根据检索条件向左，向右查询最靠近检索条件的记录值A，B，间隙锁区间为（A，B）

主要通过两个方面来实现防止幻读

1.防止间隙内有新数据被插入

2.防止已经存在的数据，更改成间隙内的数据

### Innodb下的锁

1.**共享锁，排它锁**（都是悲观锁）

​    共享锁也叫读锁（SELECT ... LOCK IN SHARE MODE;）

​    排它锁也叫写锁（SELECT ... FOR UPDATE;）

​    即一个事物在读取一个数据行的时候，其他事物也可以读，但不能对该数据行进行增删改

​    即一个事物对该数据行进行增删改的时候，其他事物不能读也不能改

2.**记录锁（行锁），间隙锁（gap锁），next-key锁（记录锁+间隙锁）**（全都属于排它锁）

​    innodb默认的加锁方式是next-key锁

3.**悲观锁，乐观锁**

​    悲观锁：当事物A对某行数据应用了锁，并且这个事物把锁释放后，其他事物才能执行与该锁冲突的操作。

​    乐观锁：在提交数据更新之前，每个事物都会检查在该事物读取数据后没有没有其他事物又修改了数据，如果其他事物又更新的话，那么当前正在提交的事物回滚。

### 在innodb下，加锁之前，为什么要先start transaction?

innodb下事物一旦提交或者回滚，就会自动释放事物中的锁，innodb的情况下autocommit=1即开启自动提交，在自动提交模式下，每执行一句sql，就自动提交事物，锁也会立即释放，所以我们在进行锁操作之前，会关闭自动模式开启手动模式

### 主从同步



### 死锁检测

死锁日志：deadlock

死锁超时：当查询的时间达到所等待超时的设定后放弃锁请求，将持有最少行级排它锁的事物回滚

reference：http://hedengcheng.com/?p=844，http://hedengcheng.com/?p=771

### 索引优化

不走索引：like，！=（反向查询），not in，is null

索引优化：迁移历史数据，分表，最左原则，explain

reference：https://www.jianshu.com/p/46641d098a17

### mysql打满问题分析

是不是有慢sql，分析数据库有多少个线程数，如果线程数都被慢sql占用了，数据库cpu就会被打满，但是如果sql瞬间执行完成，就不会有这个问题

