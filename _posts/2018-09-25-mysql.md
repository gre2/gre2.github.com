---
layout: post
title: "mysql问答"
description: "mysql"
category: [java,mysql]
tags: [mysql]
---
{% include JB/setup %}

# mysql

### 索引

索引是帮助Mysql高效获取数据的**排好序**的**数据结构**

### 索引数据结构

* 二叉树

  极限情况单边树，不平衡

* 红黑树

  自平衡，但是数据量大的时候深度也很大（1-2-4-8-16-2的n次幂）

* hash表

  hash之后直接找到磁盘文件指针，虽然很快，但是搞不定范围查找这个情景  

* b-tree树

  度-节点的数据存储个数，为什么不把索引数据存储在一个节点里面？

### 为什么不把索引数据存储在一个节点里面？(说的是主键索引)

java-cpu-ram（内存）===硬盘，先从内存拿，取不到从硬盘拿，硬盘和内存的最小单位是叶（4kb），交互只能是叶的整数倍

磁盘拿数据到内存，最小的交互单位是4kb，一次最多拿几十k的数据，因为太大的话计算机底层不支持，所以不可能把索引都放在一个节点里面。

查看mysql叶节点存储数据的大小，show global status like 'Innodb page size';查询结果是16384byte=16Kb，叶节点就是下图中的每一行（15+56+77）

为什么要设置成16kb？ 

![innodb](http://ww1.sinaimg.cn/large/87a42753ly1gbnz2vlzlyj20ps0bagox.jpg)

![mysaim](http://ww1.sinaimg.cn/large/87a42753ly1gbralwkn66j20us0c6q6e.jpg) 

主键是bigint，占用8byte，索引的子节点（和索引成对出现的磁盘文件指针）占用6byte（15旁边的空格就是磁盘文件指针），也就是说一个叶节点可以存储16384byte  / (6byte+8byte) ==1170个索引数据

mysaim引擎叶子节点的data数据放的是索引所在行的磁盘文件指针

innodb引擎叶子节点的data数据放的是索引索引所在行的其他所有字段 

mysql一般把根节点（15+56+77）放到内存，而不是从磁盘查找，之后才在磁盘查找 

### 联合索引底层数据结构

![企业微信截图_3e33f968-0ed1-4855-980a-60f07268d71b.png](http://ww1.sinaimg.cn/large/87a42753ly1gbtfeffgevj213a0gi486.jpg) 

指针是双向的!!!!

先比较第一列，整型，之后比较字符串（ASCII码），之后date

如果三个字段是联合主键，下面的data是其他字段

如果三个字段是普通索引，下面的data是主键

图示代表a，ab，abc ，ac（只用a的索引，索引比较先比较第一个，之后第二个，之后第三个，不能从一跳到三）

例如 a=1 and b>1 and c=1 走ab索引，因为必须先找到 a=1 and b>1的所有记录，想就相当于这个条件的所有数据了（范围右边索引列失效，但是范围当前位置的索引是有效的）（btree是节点比较必须是等于）

结合数据结构，不等于肯定是不走索引的 ，like '%wu'肯定不走，like'wu%'走（*的话不会走索引，可以试试覆盖索引）

实例：abcd是联合索引（mysql内部优化，之后也可以看explain查看，关注key_len和ref）select * from A

a=1 and b=1 and c=1 and d=1(走4个索引)

a=1 and c=1 and b=1 and d=1(走4个索引)

a=1 and d=1 and c=1 and b=1(走4个索引)

d=1 and c=1 and b=1 and a=1(走4个索引)

a=1 and b=1 and d>1 and c=1(走4个索引)

a=1 and b=1 and d=1 and c>1(走3个索引)

a>1 and b=1 and c=1 and d=1(不走索引，全表扫描，有可能值在联合索引里面没有1这个节点，没办法先根据a=1找之后走链表 )（用覆盖索引）

a>=1 and b=1 and c=1 and d=1（不走索引，全表扫描）

a=1 and b=1 and  d=1 order by c asc（desc使用索引情况一样，底层数据结构双向指针）（c走索引，虽然key_len里面显示只用了两个索引，但是extra里面没有file sort，所以代表c是走索引的）

a=1 and b=1 order by d（d不走索引，extra里面有filesort）

a=1 and d=1 order by b，c（排序时b，c走索引了，extra里面没有filesort）

### 磁盘存取原理

![企业微信截图_46597d5b-2b59-4707-bdcf-4c474024553e.png](http://ww1.sinaimg.cn/large/87a42753ly1gbsm495dd0j218w0kan47.jpg)

### 存储引擎

针对的是表，不是库

数据存储的磁盘位置，/var/lib/mysql/，先是库，后是表

frm文件存储的是表结构的定义

ibd文件存储的是 b+tree和数据的一个汇总文件

### 执行计划explain

type列：表示关联类型或访问类型，即myssql决定如何查找表中的行

最优到最差

system(表就一条记录)

const(唯一索引，结果集就一个记录)

eq_ref（关联的字段是主键索引或者唯一索引）

ref（关联的字段不是主键或者唯一索引）

range（范围查询）

index（扫描全表索引，从索引里面读取）

all（从硬盘读写，查询字段不全是索引）

extra列（具体见文档）（覆盖索引？索引前导列？优化成using index）

using index（查询的列被索引覆盖，并且where筛选条件是索引的前导列）

using where using index （查询的列被索引覆盖，并且where筛选条件是索引列之一，但是不是索引的前导列，也就是无法通过索引来查找到符合条件的数据）

using where（查询的列未被索引覆盖，并且where筛选条件不是索引的前导列）

null（查询的列未被索引覆盖，并且where筛选条件是索引的前导列）

using temporary（临时表 distinct，group by等场景会导致，查询的列未被索引覆盖）

using filesort（查询的列未被索引覆盖，如果被索引覆盖，不需要再排序是因为b-tree+提前排好了 ）

key_len列和ref列

当ref为空时，不一定没有走索引，看key_len的索引位置的计算

当key_len为空，肯定没有用索引

### 索引类型

1.聚集索引（一般是主键）：索引和数据聚集在一起了，叶子节点的data数据，根据条件查找到数据就能知道别的字段是什么值而mysaim通过数据找到磁盘文件指针，再在另外一个文件里面找别的字段的值，这样的就是非聚集索引

2.非聚集索引：索引上只包含被建立索引的数据，以及一个行定位符，这个行定位符，可以理解为一个聚集索引物理排序的指针，通过这个指针，可以找到行数据

3.覆盖索引：被查询的所有列都是索引，这时不用通过行定位符再到row上获取

### Innodb为什么需要主键，为什么要自增的整型（聚集索引）

innodb数据文件必须有一个主键索引来帮我们组织数据结构，设计如此（上图）

如果不是自增的话，b+tree叶子节点是递增的，如果不是自增的整型会导致树进行分裂，平衡之后移动，耗费资源

innodb自增主键会把数据自动向后插入，避免了插入过程中的聚集索引的排序问题，聚集索引的排序，必然会带来大范围的数据的物理移动，带来磁盘io的性能损耗，如果聚集索引的值可以改变的话，那么也会发出物理磁盘上的移动，于是就可能出现磁盘页分裂（索引存储在磁盘上！！！），表碎片横生

### 不要创建过多的索引：
1.创建和维护索引要耗费时间，这种时间随着数据量的增加而增加；
2.创建索引占空屋里空间，聚簇索引占用空间更大；
3.对表中的数据进行增删改，索引也要动态维护

### 索引的数据结构   -   B-树

##### 1.索引为什么要树结构存储

树的查询效率高，而且有序

##### 2.为什么没有用二叉树呢

二叉树时间复杂度O(logN)，从算法逻辑来讲，查找速度和比较次数都是最小的，但是磁盘IO问题，数据库的索引存储在磁盘上，当数据量很大的时候，索引几个G，不可能把整个索引全部加载到内存，能做的只是逐一加载每一个磁盘页，这里的磁盘页对应索引树的节点。

![](http://ww1.sinaimg.cn/large/87a42753ly1g36v50fbr3j20jx0e3wfx.jpg)

二叉树的查找，4次磁盘IO，找到元素10

![](http://ww1.sinaimg.cn/large/87a42753ly1g36v5cfcksj20gp0bwq56.jpg)

为了减少磁盘IO，我们需要把瘦高的树，变的矮胖，这就是B-树的特征之一。

##### 3.B-树

**多路平衡查找树，它的每个节点最多包含k个孩子，k被称为B树的阶，k的大小取决于磁盘页的大小。**

特征：

1.根节点最少两个子女

2.每个中间节点都包含k-1个元素和k个孩子，m/2<=k<=m

3.每个叶子节点都包含k-1个元素，m/2<=k<=m

4.所有的叶子节点位于同一层

5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的至于分划

![](http://ww1.sinaimg.cn/large/87a42753ly1g36v5nkwtmj20is07xta0.jpg)

在内存中定位，比较3,5，相比于磁盘IO的速度，内存耗时可以忽略不计

##### 4.B-树的卫星数据

![](http://ww1.sinaimg.cn/large/87a42753ly1g36v5yotlxj20it0biwh3.jpg)

##### 5.B-树的新增   -  自平衡

![](http://ww1.sinaimg.cn/large/87a42753ly1g36v6jv7z1j20iy0npdlv.jpg)

##### 6.B-树的删除

![](http://ww1.sinaimg.cn/large/87a42753ly1g36v70a6luj20jd0x0103.jpg)

### Mysql索引数据结构

B+树是基于B-树的一种变体，有着比B-树更高的查询性能

##### B+树的特征

1.k阶b+树，中间节点包含k个元素（B-树是k-1个元素），每个元素不保存数据，只用来记录索引，所有数据都保存在叶子节点

2.所有叶子节点包含了全部的元素信息，及指向含这些元素记录的指针，且叶子节点本身依关键字的大小自小而大顺序连接

3.所有中间节点元素都同时存在于子节点，在子节点元素中是最大或最小元素

   **叶子节点形成了一个有序链表**

![](http://ww1.sinaimg.cn/large/87a42753ly1g36v7dwr8mj20im07cwfo.jpg)

##### B+树的卫星数据

卫星数据指的是索引元素指向的数据记录，比如数据库中的某一行

**在数据库的聚集索引中，叶子节点直接包含卫星数据，在非聚集索引中，叶子节点带有指向卫星数据的指针**

![](http://ww1.sinaimg.cn/large/87a42753ly1g36v83qkbgj20iv0aojtx.jpg)

##### B+树查询性能（单行查询  +  范围查询）之三个优势

在B+树中**单行查询**找3这个元素和B-树的不同体现在

1.B+树中间节点没有卫星数据，相同大小的磁盘页可以容纳更多的节点元素，IO次数更少

2.B+树查询必须找到叶子节点查询性能稳定

![](http://ww1.sinaimg.cn/large/87a42753ly1g36v8im6eej20iy0ssaf4.jpg)



在B+树中**范围查询**找3到11的元素和B-树的不同体现在

1.B-树只能采用中序遍历的方法，B+树只需要在链表上做遍历即可



![](http://ww1.sinaimg.cn/large/87a42753ly1g36v9918xsj20he1c4n4r.jpg)



![](http://ww1.sinaimg.cn/large/87a42753ly1g36v9xtzdxj20h20regqz.jpg)



### 存储引擎

MyISAM表锁（偏读）；Innodb行锁，事务（偏写）

MyISAM读锁（应用范围：数据迁移）：当前session和其他session都可以读该表，当前session中插入和更新锁定的表都会报错，其他session插入或更新则会等待

MyISAM写锁：当前session可以进行读写，其他session进行读写会等待

MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁

Innodb行锁：开启事务，session1更新某一行，session2更新同一行被阻塞，但是更新其他行正常

### 事务ACID

原子性Atomicity：事务是一个原子操作，对数据的修改要么全成功，要么全失败

一致性Consistent：在事务开始和完成时，数据都必须保持一致状态。意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（b树索引和双向链表）也都必须是正确的

隔离性Isolation：数据库提供一定的隔离机制，保证事务在不受外部并发操作影响的独立环境执行，意味着事务处理过程中的中间状态对外部是不可见的

持久性Durable：事务完成后，他对数据的修改是永久性的，即使出现系统故障也能保持

### 并发事务处理带来的问题

更新丢失： 第二个事务覆盖第一个事务的值，用乐观锁解决 where version=？，version是操作之前查询出来的值

脏读：事务A读取到事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作，此时如果B事务回滚，A读取的数据无效，不符合一致性要求

不可重复读：事务A读取到事务B已经提交的修改数据，不符合隔离性（【事务A一直都没有提交】事务A先读了一次，事务B对数据进行修改，没有提交的时候，事务A读不到，没有脏读，事务B提交了，事务A就可以读到了，两次事务A读到的数据不一致，不符合隔离性）

幻读： 事务A读取到了事务B提交的新增数据，不符合隔离性（【事务A一直都没有提交】事务A查结果350，事务B变成了300并且提交了，事务A再查350，解决了不可重复读，事务B新增了一个数据，事务A查询不到，事务A做了一个修改的操作或者新增的操作，事务B对数据库的更改，事务A就可以看见了（mvcc机制），不符合隔离性）

可重复读使用了MVCC机制，select不会更新版本号，是快照读（历史版本），insert，update和delete会更新版本号，是当前读（当前版本），例如：事务A一直都没有提交，事务A查结果350，事务B变成了300并且提交了，事务A执行了update操作减50，事务A再查询250

脏读是事务B里面修改了数据

幻读是事务B里面新增了数据

### Mysql事物的隔离级别

![](http://ww1.sinaimg.cn/large/87a42753ly1g36va8vx2jj20n207fn0t.jpg)

mysql默认的隔离级别是可重复读

查询隔离级别：show variables like  'tx_isolation'

修改数据库的隔离级别：set tx_isolation='REPEATABLE-READ'

spring可以设置事务隔离级别，mysql也可以设置事务隔离级别，以spring为主

串行化：强制事物排序，使之不可能存在相互冲突，事物1没有提交之前，不允许事物2更改数据

### 如何防止幻读  -   间隙锁

根据检索条件向左，向右查询最靠近检索条件的记录值A，B，间隙锁区间为（A，B）

主要通过两个方面来实现防止幻读

1.防止间隙内有新数据被插入

2.防止已经存在的数据，更改成间隙内的数据

### Innodb下的锁

![](http://ww1.sinaimg.cn/large/87a42753ly1g36vaj0k4jj20pm0aqabw.jpg)

1.**共享锁（读锁），排它锁（写锁）**（都是悲观锁）

​    共享锁也叫读锁（SELECT ... LOCK IN SHARE MODE;）

​    排它锁也叫写锁（SELECT ... FOR UPDATE;）

​    即一个事物在读取一个数据行的时候，其他事物也可以读，但不能对该数据行进行增删改

​    即一个事物对该数据行进行增删改的时候，其他事物不能读也不能改

2.**记录锁（行锁），间隙锁（gap锁），next-key锁（记录锁+间隙锁）**（全都属于排它锁）

​    innodb默认的加锁方式是next-key锁

3.**悲观锁，乐观锁**

​    悲观锁：当事物A对某行数据应用了锁，并且这个事物把锁释放后，其他事物才能执行与该锁冲突的操作。

​    乐观锁：在提交数据更新之前，每个事物都会检查在该事物读取数据后没有没有其他事物又修改了数据，如果其他事物又更新的话，那么当前正在提交的事物回滚。

### 在innodb下，加锁之前，为什么要先start transaction?

innodb下事物一旦提交或者回滚，就会自动释放事物中的锁，innodb的情况下autocommit=1即开启自动提交，在自动提交模式下，每执行一句sql，就自动提交事物，锁也会立即释放，所以我们在进行锁操作之前，会关闭自动模式开启手动模式

### 主从同步

0.当slave连接到master的时候，master会为slave开启binlog dump线程
1.master数据发生变更，该事件（insert，update，delete）会被按照顺序写到binlog，binlog dump线程会通知slave，并将相应的binlog内容发给slave
2.**此时slave机器会创建两个线程**
   IO线程：接收binlog内容，将内容写到relay log中
   SQL线程：读取relay log，根据relay log的内容对slave数据库进行修改
3.**Mysql支持复制类型**
   语句复制：mysql默认采用语句复制，效率高
   行复制：没法精确复制时，采用行复制，把主库行数据，直接复制到从库
   混合复制：语句和行复制的混合

4.主从复制流程图


![](http://ww1.sinaimg.cn/large/87a42753ly1g36vaux1sbj20dl09nt9t.jpg)

5.主从复制控制台图

![](http://ww1.sinaimg.cn/large/87a42753ly1g36vb59vx0j20mq0fc79e.jpg)

![](http://ww1.sinaimg.cn/large/87a42753ly1g36vbjoetrj20nk0k0tfc.jpg)

### 死锁检测

死锁日志：deadlock

死锁超时：当查询的时间达到所等待超时的设定后放弃锁请求，将持有最少行级排它锁的事物回滚

reference：http://hedengcheng.com/?p=844

### 索引优化

不走索引：like，！=（反向查询），not in，is null

索引优化：迁移历史数据，分表，最左原则，explain

上锁reference：http://hedengcheng.com/?p=771

​                             https://www.jianshu.com/p/46641d098a17

为什么最左原则：

联合索引(col1, col2,col3)也是一棵B+Tree，其非叶子节点存储的是第一个关键字的索引，而叶节点存储的则是三个关键字col1、col2、col3三个关键字的数据，且按照col1、col2、col3的顺序进行排序。

![](http://ww1.sinaimg.cn/large/87a42753ly1g36vc0jdemj20hk06rdh3.jpg)

reference：https://blog.csdn.net/weixin_30531261/article/details/79329722

### mysql打满问题分析

是不是有慢sql，分析数据库有多少个线程数，如果线程数都被慢sql占用了，数据库cpu就会被打满，但是如果sql瞬间执行完成，就不会有这个问题

