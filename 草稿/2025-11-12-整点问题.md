---
layout: post
title: "整点问题（原理+场景）"
description: ""
category: [jekyll, github]
tags: [jekyll, github]
---
{% include JB/setup %}
### 布隆过滤器
* 传统布隆过滤器由一个初始全为 0 的位数组和多个独立的哈希函数组成。添加元素时，会通过多个哈希函数将元素映射为位数组中的多个位置，再把这些位置标记为 1；查询元素时，同样用这几个哈希函数得到对应位置，若所有位置均为 1，则元素 “可能存在”，若有任一位置为 0，则元素 “一定不存在”。不过它存在局限性，元素增多会让误判率升高，且无法扩容，同时因位数组的位置可能被多个元素共享，无法删除单个元素。
* TairBloom 为解决传统布隆过滤器的扩容问题，采用 Scalable Bloom Filter 设计。当当前布隆过滤器中的元素达到预设容量，误判率即将超出阈值时，它不会修改原有过滤器，而是创建一个新的布隆过滤器，将多个过滤器组合使用。新过滤器的容量默认是上一层的 2 倍，且始终维持初始设定的误判率。查询时从最新的过滤器开始遍历检查，直到所有层级检查完毕，以此保证在数据量增长时，误判率依然稳定。
* 黑名单，海量用户活动推送去重（防止多推）

### nlb和slb
* slb7层，可以根据http/https协议，url，域名，cookie等信息进行请求分发，毫秒级。可以配合nginx使用，也可以不配合
```aiignore
server {
    listen 80;
    server_name tag-platform-web-test.tag-platform-test.paas.test;
    
    location /api/meta/ {
        proxy_pass http://service-a-cluster/;
    }
    
    location /api/user/ {
        proxy_pass http://service-b-cluster/;
    }
}

```
* nlb4层，根据tcp/udp连接进行分发（ip地址和端口），延迟低，微妙级别。可以配合nginx使用(nlb将流量发到nginx机群，nginx来路由)，也可以不配合。
```aiignore
nlb服务发现处理，1.预置后端列表（手动配置后端服务ip，健康检查剔除故障节点），2.动态发现后端（如k8s自动同步服务实例列表，利用k8s的selector字段字段关联pod，k8s自动将匹配pod的ip注册为nlb后端，无需手动配置ip）
```
```aiignore
apiVersion: v1
kind: Service
metadata:
  name: my-service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 8080
  selector:
    app: my-app
```


### kafka和rocketmq区别【从协议说就行】，原理（主要是搞明白kafka）
* https://www.bilibili.com/video/BV1m7421Z7fN/?spm_id_from=333.337.search-card.all.click&vd_source=d163c2ddcb7dcb1c2df5a0b53416de2b
* partition 是完整消息，queue是offset对commitlog的索引
* rmq是架构的减法，功能的加法，zk重换成nameserver，后来kafka也意识到zk重，去掉换成zraft算法
* kafka写partition就是写下面的segment，但是多个topic对应多个segment文件，同时写多个topic，每个segment内部是顺序写，但是 segemnt在磁盘位置不同，此时就不一定是顺序写了。但是rmq是一个文件的顺序写 
* 简化备份模型， partition存在不同broker下，并对partition配置副本（比如partition1和partition2存在broker1，但是partition1的副本存在broker2上，partition1分为leader和fllower），主从partition进行数据同步，其实就是同步segment 。rmq直接同步commitlog文件 
* rmq支持tag ，事物，延迟，死信
* 零拷贝https://www.bilibili.com/video/BV1Zy411e7qY?spm_id_from=333.788.videopod.sections&vd_source=d163c2ddcb7dcb1c2df5a0b53416de2b rmq通过mmap能获取到消息内容，但是sendfile获取不到，所以rmq没有用sendfile。因为sendfile比mmap更少的拷贝次数，所以kafka更快

### datax原理
https://blog.51cto.com/u_15294985/5147819
启动job，拆分task，根据预设的并发数量/5计算启动多少个taskgroup。之后taskgroup管理task，每个task用reader读取数据放channel，writer从channel取数据去写 
代码在core里面Engine.entry，检查配置，之后就是container.start启动。两个实现，job和taskgroup
[![pZPCQxJ.png](https://s21.ax1x.com/2025/11/14/pZPCQxJ.png)](https://imgchr.com/i/pZPCQxJ)
* split先拆分，但是拆分之前需要先找到并发数，有record条数级别，byte级别，channel级别。前面2个级别的数据取最小值，channel优先级最低
### 线程池怎么设置的大小，这么设计的依据是什么？
* 目的是削峰，那也可以用mq，功能更全 
* 动态线程池（调用原生方法修改，可以保证线程安全 ）
* 一个java应用可以设置很多线程，取决于用户级别限制（1w+），还取决于线程栈内存Xss限制（最大线程数 ≈ （系统可用内存 - JVM堆内存 - 其他进程内存） / 单个线程栈大小）

### flink原理
* flink-14，15反压，16倾斜，20去重，39面试基础，40进阶，架构，41选型

### 项目介绍（背景，架构，难点，问题）

### http和rpc
https://www.bilibili.com/video/BV1Qv4y127B4/?spm_id_from=333.1387.upload.video_card.click&vd_source=d163c2ddcb7dcb1c2df5a0b53416de2b
